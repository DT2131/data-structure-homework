#include <bits/stdc++.h>

using namespace std;
const int MAXN=1e7+10;
typedef struct Node{
    int x1,x2,y1,y2,dir;
    bool operator < (const Node &a)const{
        if(x1==a.x1){
            if(x2==a.x2){
                if(y1==a.y1){
                    if(y2==a.y2) return dir<a.dir;
                    else return y2<a.y2;
                }else return y1<a.y1;
            }else return x2<a.x2;
        }else return x1<a.x1;
    }
}Node;
map <Node,int> mp;
vector <int> edge[MAXN];
Node node[MAXN];
int cnt=0,n,k,head=-1,de=0;
int dep[MAXN]={0};
int fa[MAXN]={-1};
int sta[MAXN];
bool vis[MAXN]={0},output_control;
void ini(){
    memset(dep,0,sizeof(dep));memset(fa,-1,sizeof(fa));memset(vis,0,sizeof(vis));
    mp.clear();for(int i=0;i<=cnt;i++) edge[i].clear();
    cnt=0;head=-1;de=0;
}
bool judge(Node now,int x,int y){
    if(now.dir&&now.x1&&now.x1<now.x2) return 0;
    if(!now.dir&&now.y1&&now.y1<now.y2) return 0;
    if(x==0&&y==0) return 0;
    if(y!=0&&x>y) return 0;
    return 1;
}
void build(){
    queue <Node> que;Node now={n,n,0,0,0};
    que.push(now);
    mp[now]=++cnt;
    node[cnt]=now;
    fa[cnt]=-1;
    while(!que.empty()){
        now=que.front();
        que.pop();
        int x=mp[now],y;
        if(now.dir){
            now.y1=n-now.x1,now.y2=n-now.x2;
            for(int i=0;i<=now.y2&&i<=k;i++){
                for(int j=0;j<=now.y1&&(i+j)<=k;j++){
                    de++;
                    Node pos={now.x1,now.x2,now.y1-j,now.y2-i,0};
                    if(judge(pos,i,j)){
                        if(mp[pos]==0){
                            mp[pos]=++cnt;
                            node[cnt]=pos;
                            if(pos.x1!=0||pos.x2!=0) que.push(pos);
                        }
                        y=mp[pos];
                        edge[x].push_back(y);
                    }
                }
            }
        }else{
            now.x1=n-now.y1,now.x2=n-now.y2;
            for(int i=0;i<=now.x2&&i<=k;i++){
                for(int j=0;j<=now.x1&&(i+j)<=k;j++){
                    de++;
                    Node pos={now.x1-j,now.x2-i,now.y1,now.y2,1};
                    if(judge(pos,i,j)){
                        if(mp[pos]==0){
                            mp[pos]=++cnt;
                            node[cnt]=pos;
                            if(pos.x1!=0||pos.x2!=0) que.push(pos);
                        }
                        y=mp[pos];
                        edge[x].push_back(y);
                    }
                }
            }
        }
    }
}
void debug(){
    cout<<"de:  "<<de<<endl;
    cout<<"cnt: "<<cnt<<endl;
    for(int i=1;i<=cnt;i++)
        cout<<i<<": "<<node[i].x1<<' '<<node[i].x2<<' '<<node[i].y1<<' '<<node[i].y2<<' '<<node[i].dir<<endl;
    for(int i=1;i<=cnt;i++){
        cout<<i<<": ";
        for(int j=0;j<edge[i].size();j++)
            cout<<edge[i][j]<<' ';
        cout<<endl;
    }
}
void show_way(int x){
    if(x==-1) return ;
    show_way(fa[x]);
    cout<<"Node:  "<<x<<"  position1:  "<<node[x].x1<<"  "<<node[x].x2<<"  boat:  "<<n-node[x].x1-node[x].y1<<"  "<<n-node[x].x2-node[x].y2<<"  position2:  "<<node[x].y1<<"  "<<node[x].y2<<"  direction:  "<<node[x].dir<<endl;

}
void solve(){
    int now,pos,len,lim=cnt+1;
    queue <int> que;
    que.push(1);
    dep[1]=1;
    while(!que.empty()){
        now=que.front();
        que.pop();
        len=edge[now].size();
        for(int i=0;i<len;i++){
            pos=edge[now][i];
            if(!dep[pos]){
                dep[pos]=dep[now]+1;
                fa[pos]=now;
                if(edge[pos].empty()){
                    cout<<"We need at least "<<dep[pos]-1<<" steps to solve the problem."<<endl;
                    show_way(pos);
                    cout<<endl;
                    return ;
                }
                else que.push(pos);
            }
        }
    }
    if(lim==cnt+1) puts("Sorry, no answer");
}
void show_path(){
    cout<<"feasible path: "<<endl;
    for(int i=0;i<=head;i++)
        cout<<"Node:  "<<sta[i]<<"  position1:  "<<node[sta[i]].x1<<"  "<<node[sta[i]].x2<<"  boat:  "<<n-node[sta[i]].x1-node[sta[i]].y1<<"  "<<n-node[sta[i]].x2-node[sta[i]].y2<<"  position2:  "<<node[sta[i]].y1<<"  "<<node[sta[i]].y2<<"  direction:  "<<node[sta[i]].dir<<endl;
    cout<<endl;
}
int dfs(int now,int left){
    vis[now]=1;
    sta[++head]=now;
    int len=edge[now].size(),pos;
    int ans=0;
    if(len==0){
        if(!output_control) show_path();
        ans++;
    }else{
        if(left>0){
            for(int i=0;i<len;i++){
                pos=edge[now][i];
                if(!vis[pos])
                ans+=dfs(pos,left-1);
            }
        }
    }
    vis[now]=0;
    head--;
    return ans;
}
void search_all(){
    cout<<"Please enter the step limit: ";
    int p;cin>>p;cout<<endl;
    cout<<"Print all the path?(Y/N): ";
    char t;cin>>t;
    output_control=(t=='Y')?0:1;
    cout<<"There are total "<<dfs(1,p)<<" answer(s) with the step limit of "<<p<<"."<<endl;
}
int main(){
    while(1){
        system("cls");
        cout<<"please enter the number of monk(s) or barbarian(s) and load limit of ship ( please separate them by space ):  ";
        cin>>n>>k;
        cout<<endl;
        build();
        while(1){
            cout<<"1.Find the shortest path"<<endl;
            cout<<"2.Find the all the path with step limit x"<<endl;
            cout<<"3.Change the input"<<endl;
            cout<<"4.Developer Mode"<<endl;
            cout<<"Please enter 1 2 3 or 4 to continue: ";
            int p;
            cin>>p;
            if(p==1) solve();
            else if(p==2) search_all();
            else if(p==4) debug();
            else break;
            system("pause");
        }
        ini();
    }
}
